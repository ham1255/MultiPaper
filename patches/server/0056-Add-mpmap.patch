From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Fri, 24 Dec 2021 23:23:42 +1000
Subject: [PATCH] Add /mpmap


diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
index 4e86da4e5f8af5ab6e07f846545f7b4e51e629aa..dc9d2b7ff44b0ca31ab1b6e6258795c7df114f40 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
@@ -5,6 +5,7 @@ import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.SimpleCommandMap;
 import puregero.multipaper.commands.MPDebugCommand;
+import puregero.multipaper.commands.MPMapCommand;
 import puregero.multipaper.commands.ServersCommand;
 
 public class CraftCommandMap extends SimpleCommandMap {
@@ -25,6 +26,7 @@ public class CraftCommandMap extends SimpleCommandMap {
     private void setDefaultCommands() {
         register("multipaper", new MPDebugCommand("mpdebug"));
         register("multipaper", new ServersCommand("servers"));
+        register("multipaper", new MPMapCommand("mpmap"));
     }
     // MultiPaper end
 
diff --git a/src/main/java/puregero/multipaper/commands/MPMapCommand.java b/src/main/java/puregero/multipaper/commands/MPMapCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..027aa436e3ba60774323346d855751ebda86d690
--- /dev/null
+++ b/src/main/java/puregero/multipaper/commands/MPMapCommand.java
@@ -0,0 +1,184 @@
+package puregero.multipaper.commands;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import puregero.multipaper.MultiPaper;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class MPMapCommand extends Command {
+
+    public MPMapCommand(String command) {
+        super(command);
+        setPermission("multipaper.command.mpmap");
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String[] args) {
+        if (!testPermission(sender)) return false;
+
+        if (!(sender instanceof Player player)) {
+            sender.sendMessage(ChatColor.RED + "Only players can execute this command.");
+            return false;
+        }
+
+        int radius = 8;
+
+        sendMap(player, radius);
+
+        return true;
+    }
+
+    private record LocalExternalCache(int localPlayers, int externalPlayers, List<String> servers) {
+        public int getTotal() {
+            return localPlayers + externalPlayers;
+        }
+    }
+
+    private LocalExternalCache computeLocalExternalCache(Player player, int radius) {
+        List<Player> players = (List<Player>) player.getWorld().getNearbyPlayers(player.getLocation(), (16 * radius), (16 * radius));
+        List<String> servers = new ArrayList<>();
+        int externalPlayers = 0;
+        int localPlayers = 0;
+        for (Player loopPlayer : players) {
+            if (!servers.contains(loopPlayer.getExternalServerName())) servers.add(loopPlayer.getExternalServerName());
+            if (loopPlayer.isExternalPlayer()) {
+                externalPlayers++;
+            } else {
+                localPlayers++;
+            }
+        }
+        return new LocalExternalCache(localPlayers, externalPlayers, servers);
+    }
+
+    private Component getStats(Player player, int radius, int row, LocalExternalCache cache) {
+        Component component = Component.text("");
+        int actualRow = radius + row;
+        switch (actualRow) {
+            case 0 -> component = component.append(Component.text("Stats: ").color(NamedTextColor.WHITE));
+
+            case 1 -> component = component.append(Component.text("   Chunk: ").color(NamedTextColor.WHITE).append(Component.text(player.getChunk().getX()+ ", " + player.getChunk().getZ()).color(NamedTextColor.YELLOW)));
+            case 2 -> component = component.append(Component.text("   Map radius: ").color(NamedTextColor.WHITE).append(Component.text(radius + " chunks").color(NamedTextColor.YELLOW)));
+            case 3 -> component = component.append(Component.text("   Facing: ").color(NamedTextColor.WHITE).append(Component.text(getCardinalDirection(player)).color(NamedTextColor.YELLOW)));
+            case 4 -> component = component.append(Component.text("   Servers: ").color(NamedTextColor.WHITE).append(Component.text(cache.servers.size()).color(NamedTextColor.YELLOW)));
+
+            case 6 -> component = component.append(Component.text("   Players: ").color(NamedTextColor.WHITE).append(Component.text(cache.getTotal()).color(NamedTextColor.YELLOW)));
+            case 7 -> component = component.append(Component.text("   External: ").color(NamedTextColor.WHITE).append(Component.text(cache.externalPlayers()).color(NamedTextColor.YELLOW)));
+            case 8 -> component = component.append(Component.text("  Local: ").color(NamedTextColor.WHITE).append(Component.text(cache.localPlayers()).color(NamedTextColor.YELLOW)));
+
+            case 10 -> component = component.append(Component.text("   World: ").color(NamedTextColor.WHITE).append(Component.text(player.getWorld().getName()).color(NamedTextColor.YELLOW)));
+            case 11 -> component = component.append(Component.text("   entities (L): ").color(NamedTextColor.WHITE).append(Component.text(player.getWorld().getEntityCount()).color(NamedTextColor.YELLOW)));
+            case 12 -> component = component.append(Component.text("   chunks (L): ").color(NamedTextColor.WHITE).append(Component.text(player.getWorld().getChunkCount()).color(NamedTextColor.YELLOW)));
+            case 13 -> component = component.append(Component.text("   view distance: ").color(NamedTextColor.WHITE).append(Component.text(player.getWorld().getViewDistance()).color(NamedTextColor.YELLOW)));
+            case 14 -> component = component.append(Component.text("   simulation distance: ").color(NamedTextColor.WHITE).append(Component.text(player.getWorld().getSimulationDistance()).color(NamedTextColor.YELLOW)));
+
+
+            case 16 -> component = component.append(Component.text(" (L): ").color(NamedTextColor.WHITE).append(Component.text("Locally").color(NamedTextColor.YELLOW)));
+        }
+        return component;
+    }
+
+    private void sendMap(Player player, int radius) {
+        Component message = Component.text(System.lineSeparator()).append(getHeader(radius, 'W'));
+        LocalExternalCache cache = computeLocalExternalCache(player, radius);
+        for (int row = -radius; row <= radius; row++) {
+            Component componentRow = getMapRow(player, radius, row, 0, 'N', 'S');
+            Component statsRow = getStats(player, radius, row, cache);
+            Component finalRow = componentRow.append(statsRow);
+            message = message.append(Component.text(System.lineSeparator())).append(finalRow);
+        }
+        message = message.append(Component.text(System.lineSeparator())).append(getHeader(radius, 'E'));
+        player.sendMessage(message);
+    }
+
+    private NewChunkHolder getChunkHolder(Player player, int x, int z) {
+        return MultiPaper.getChunkHolder(player.getWorld().getName(), ((CraftPlayer) player).getHandle().blockPosition().offset(x << 4, 0, z << 4));
+    }
+
+    private Component getMapRow(Player player, int radius, int row, int directionCharRowPlacement, char leftChar, char rightChar) {
+        Component component = Component.text(" | ").color(NamedTextColor.GOLD);
+
+        if (row == directionCharRowPlacement) {
+            component = Component.text("" + leftChar + " ").color(NamedTextColor.GOLD);
+        }
+
+        int i = -radius;
+        while (i <= radius) {
+            StringBuilder builder = new StringBuilder();
+            NewChunkHolder newChunkHolder = getChunkHolder(player, row, i);
+            String serverName = newChunkHolder == null || newChunkHolder.externalOwner == null ? null : newChunkHolder.externalOwner.getName();
+            NamedTextColor color = newChunkHolder == null ? NamedTextColor.DARK_GRAY : (newChunkHolder.externalOwner == null ? NamedTextColor.WHITE : (newChunkHolder.externalOwner.isMe() ? NamedTextColor.AQUA : NamedTextColor.RED));
+
+            while (i <= radius) {
+                NewChunkHolder newChunkHolder2 = getChunkHolder(player, row, i);
+
+                if ((newChunkHolder2 == null && newChunkHolder != null) || (newChunkHolder2 != null && newChunkHolder == null) || (newChunkHolder != null && newChunkHolder2.externalOwner != newChunkHolder.externalOwner)) {
+                    break;
+                }
+
+                builder.append(row == 0 && i == 0 ? "■ " : "+ ");
+
+                i++;
+            }
+
+            Component innerComponent = Component.text(builder.toString()).color(color);
+
+            if (serverName != null) {
+                Component hover = Component.text(""). color(color);
+                innerComponent = innerComponent.hoverEvent(HoverEvent.showText(hover));
+            }
+
+            component = component.append(innerComponent);
+        }
+
+        if (row == directionCharRowPlacement) {
+            component = component.append(Component.text(rightChar + " ").color(NamedTextColor.GOLD));
+        } else {
+            component = component.append(Component.text("| ").color(NamedTextColor.GOLD));
+        }
+        return component;
+    }
+
+    private Component getHeader(int radius, char way) {
+        return Component.text("+ " + "- ".repeat(((radius * 2 + 1) / 2)) + way + " " + "- ".repeat((radius * 2 + 1) / 2) + "+").color(NamedTextColor.GOLD);
+    }
+
+    private static String getCardinalDirection(Player player) {
+        double rotation = (player.getLocation().getYaw() - 180) % 360;
+        if (rotation < 0) {
+            rotation += 360.0;
+        }
+        if (0 <= rotation && rotation < 22.5 || 337.5 <= rotation && rotation < 360.0) {
+            return "North"; // north
+        } else if (22.5 <= rotation && rotation < 67.5) {
+            return "Northeast"; // northeast
+        } else if (67.5 <= rotation && rotation < 112.5) {
+            return "East"; // east
+        } else if (112.5 <= rotation && rotation < 157.5) {
+            return "Southeast"; // southeast
+        } else if (157.5 <= rotation && rotation < 202.5) {
+            return "South"; // south
+        } else if (202.5 <= rotation && rotation < 247.5) {
+            return "Southwest"; // southwest
+        } else if (247.5 <= rotation && rotation < 292.5) {
+            return "West"; // west
+        } else if (292.5 <= rotation && rotation < 337.5) {
+            return "Northwest"; // northwest
+        } else {
+            return "■";
+        }
+    }
+
+}
diff --git a/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java b/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
index 546da05992c945e90545bcd0d3f2cb5c2c4dbb03..a21628f28a803ca2329b7f63257dad16829fe7f6 100644
--- a/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
+++ b/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
@@ -14,6 +14,7 @@ public class MultiPaperCommandPermissions {
 
         DefaultPermissions.registerPermission(PREFIX + "servers", "List details about servers running on this MultiPaper network", PermissionDefault.TRUE, commands);
         DefaultPermissions.registerPermission(PREFIX + "mpdebug", "MPDebug command", PermissionDefault.TRUE, commands);
+        DefaultPermissions.registerPermission(PREFIX + "mpmap", "MPMap command", PermissionDefault.TRUE, commands);
 
         commands.recalculatePermissibles();
     }
