From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Fri, 24 Dec 2021 23:23:42 +1000
Subject: [PATCH] Add /mpmap


diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
index 4e86da4e5f8af5ab6e07f846545f7b4e51e629aa..dc9d2b7ff44b0ca31ab1b6e6258795c7df114f40 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
@@ -5,6 +5,7 @@ import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.SimpleCommandMap;
 import puregero.multipaper.commands.MPDebugCommand;
+import puregero.multipaper.commands.MPMapCommand;
 import puregero.multipaper.commands.ServersCommand;
 
 public class CraftCommandMap extends SimpleCommandMap {
@@ -25,6 +26,7 @@ public class CraftCommandMap extends SimpleCommandMap {
     private void setDefaultCommands() {
         register("multipaper", new MPDebugCommand("mpdebug"));
         register("multipaper", new ServersCommand("servers"));
+        register("multipaper", new MPMapCommand("mpmap"));
     }
     // MultiPaper end
 
diff --git a/src/main/java/puregero/multipaper/commands/MPMapCommand.java b/src/main/java/puregero/multipaper/commands/MPMapCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..64c38af3861ff14679570f8ef7c247f300cc7a25
--- /dev/null
+++ b/src/main/java/puregero/multipaper/commands/MPMapCommand.java
@@ -0,0 +1,144 @@
+package puregero.multipaper.commands;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import puregero.multipaper.MultiPaper;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class MPMapCommand extends Command {
+
+    public MPMapCommand(String command) {
+        super(command);
+        setPermission("multipaper.command.mpmap");
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String[] args) {
+        if (!testPermission(sender)) return false;
+
+        if (!(sender instanceof Player player)) {
+            sender.sendMessage(ChatColor.RED + "Only players can execute this command.");
+            return false;
+        }
+
+        int radius = 8;
+
+        sendMap(player, radius);
+
+        return true;
+    }
+
+    private record LocalExternalCache(int localPlayers, int externalPlayers, List<String> servers) {
+        public int getTotal() {
+            return localPlayers + externalPlayers;
+        }
+    }
+
+    private LocalExternalCache computeLocalExternalCache(Player player, int radius) {
+        List<Player> players = (List<Player>) player.getWorld().getNearbyPlayers(player.getLocation(), (16 * radius), (16 * radius));
+        List<String> servers = new ArrayList<>();
+        int externalPlayers = 0;
+        int localPlayers = 0;
+        for (Player loopPlayer : players) {
+            if (!servers.contains(player.getExternalServerName())) servers.add(player.getExternalServerName());
+            if (loopPlayer.isExternalPlayer()) {
+                externalPlayers++;
+            } else {
+                localPlayers++;
+            }
+        }
+        return new LocalExternalCache(localPlayers, externalPlayers, servers);
+    }
+
+    private Component getStats(int radius, int row, LocalExternalCache cache) {
+        Component component = Component.text("");
+        int actualRow = radius + row;
+        switch (actualRow) {
+            case 0 -> component = component.append(Component.text("Stats: ").color(NamedTextColor.WHITE));
+            case 1 -> component = component.append(Component.text("   Map radius: ").color(NamedTextColor.WHITE).append(Component.text(radius).color(NamedTextColor.YELLOW)));
+            // no line 2
+            case 3 -> component = component.append(Component.text("   Players: ").color(NamedTextColor.WHITE).append(Component.text(cache.getTotal()).color(NamedTextColor.YELLOW)));
+            case 5 -> component = component.append(Component.text("   External: ").color(NamedTextColor.WHITE).append(Component.text(cache.externalPlayers()).color(NamedTextColor.YELLOW)));
+            case 7 -> component = component.append(Component.text("   Local: ").color(NamedTextColor.WHITE).append(Component.text(cache.localPlayers()).color(NamedTextColor.YELLOW)));
+            // no line 8
+            case 9 -> component = component.append(Component.text("   Servers: ").color(NamedTextColor.WHITE).append(Component.text(cache.servers.size()).color(NamedTextColor.YELLOW)));
+        }
+        return component;
+    }
+
+    private void sendMap(Player player, int radius) {
+        sendHeader(player, radius, 'W');
+        LocalExternalCache cache = computeLocalExternalCache(player, radius);
+        for (int row = -radius; row <= radius; row++) {
+            Component componentRow = getMapRow(player, radius, row, 0, 'N', 'S');
+            Component statsRow = getStats(radius, row, cache);
+            Component finalRow = componentRow.append(statsRow);
+            player.sendMessage(finalRow);
+        }
+        sendHeader(player, radius, 'E');
+    }
+
+    private NewChunkHolder getChunkHolder(Player player, int x, int z) {
+        return MultiPaper.getChunkHolder(player.getWorld().getName(), ((CraftPlayer) player).getHandle().blockPosition().offset(x << 4, 0, z << 4));
+    }
+
+    private Component getMapRow(Player player, int radius, int row, int directionCharRowPlacement, char leftChar, char rightChar) {
+        Component component = Component.text(" | ").color(NamedTextColor.GOLD);
+
+        if (row == directionCharRowPlacement) {
+            component = Component.text("" + leftChar + " ").color(NamedTextColor.GOLD);
+        }
+
+        int i = -radius;
+        while (i <= radius) {
+            StringBuilder builder = new StringBuilder();
+            NewChunkHolder newChunkHolder = getChunkHolder(player, row, i);
+            String name = newChunkHolder == null || newChunkHolder.externalOwner == null ? null : newChunkHolder.externalOwner.getName();
+            NamedTextColor color = newChunkHolder == null ? NamedTextColor.DARK_GRAY : (newChunkHolder.externalOwner == null ? NamedTextColor.WHITE : (newChunkHolder.externalOwner.isMe() ? NamedTextColor.AQUA : NamedTextColor.RED));
+
+            while (i <= radius) {
+                NewChunkHolder newChunkHolder2 = getChunkHolder(player, row, i);
+
+                if ((newChunkHolder2 == null && newChunkHolder != null) || (newChunkHolder2 != null && newChunkHolder == null) || (newChunkHolder != null && newChunkHolder2.externalOwner != newChunkHolder.externalOwner)) {
+                    break;
+                }
+
+                builder.append(row == 0 && i == 0 ? "\u25A0 " : "+ ");
+
+                i++;
+            }
+
+            Component innerComponent = Component.text(builder.toString()).color(color);
+
+            if (name != null) {
+                innerComponent = innerComponent.hoverEvent(HoverEvent.showText(Component.text(name).color(color)));
+            }
+
+            component = component.append(innerComponent);
+        }
+
+        if (row == directionCharRowPlacement) {
+            component = component.append(Component.text(rightChar + " ").color(NamedTextColor.GOLD));
+        } else {
+            component = component.append(Component.text("| ").color(NamedTextColor.GOLD));
+        }
+        return component;
+    }
+
+    private void sendHeader(Player player, int radius, char way) {
+        player.sendMessage(Component.text("+ " + "- ".repeat(((radius * 2 + 1) / 2)) + way + " " + "- ".repeat((radius * 2 + 1) / 2) + "+").color(NamedTextColor.GOLD));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java b/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
index 546da05992c945e90545bcd0d3f2cb5c2c4dbb03..a21628f28a803ca2329b7f63257dad16829fe7f6 100644
--- a/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
+++ b/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
@@ -14,6 +14,7 @@ public class MultiPaperCommandPermissions {
 
         DefaultPermissions.registerPermission(PREFIX + "servers", "List details about servers running on this MultiPaper network", PermissionDefault.TRUE, commands);
         DefaultPermissions.registerPermission(PREFIX + "mpdebug", "MPDebug command", PermissionDefault.TRUE, commands);
+        DefaultPermissions.registerPermission(PREFIX + "mpmap", "MPMap command", PermissionDefault.TRUE, commands);
 
         commands.recalculatePermissibles();
     }
